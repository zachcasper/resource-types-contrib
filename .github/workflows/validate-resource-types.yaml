name: Validate Resource Types

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Radius version number to use (e.g. 0.1.0, 0.1.0-rc1, edge). Defaults to edge.'
        required: false
        default: 'edge'
        type: string

jobs:
  validate-resource-types:
    runs-on: ubuntu-latest
    name: Validate Resource Type Schemas
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 16
      - name: Download k3d
        run: wget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash
      - name: Create k3d cluster
        # Map localhost port 80 on the external load balancer, and disable traefik and the internal load balancer.
        run: k3d cluster create --agents 2 -p "80:80@loadbalancer" --k3s-arg "--disable=traefik@server:*" --k3s-arg "--disable=servicelb@server:*" --registry-create reciperegistry:51351
      - name: Set up ORAS
        uses: oras-project/setup-oras@v1
        with:
          version: '1.2.0'
      - name: Verify ORAS installation
        run: oras version
      - name: Download rad CLI
        # TODO: remove URL and use environment variable
        run: |
          echo "Downloading latest rad CLI"
          wget -q "https://raw.githubusercontent.com/radius-project/radius/main/deploy/install.sh" -O - | /bin/bash -s edge
      - name: Initialize default environment
        run: |
          rad install kubernetes --set rp.publicEndpointOverride=localhost
          rad group create default
          rad workspace create kubernetes default --group default
          rad group switch default
          rad env create default
          rad env switch default
      - name: Verify manifests are registered
        if: env.SKIP_BUILD != 'true'
        run: |
          rm -f registermanifest_logs.txt
          # Find the pod with container "ucp"
          POD_NAME=$(
            kubectl get pods -n radius-system \
              -o jsonpath='{range .items[*]}{.metadata.name}{" "}{.spec.containers[*].name}{"\n"}{end}' \
            | grep "ucp" \
            | head -n1 \
            | cut -d" " -f1
          )
          echo "Found ucp pod: $POD_NAME"

          if [ -z "$POD_NAME" ]; then
            echo "No pod with container 'ucp' found in namespace radius-system."
            exit 1
          fi

          # Poll logs for up to 20 iterations, 30 seconds each (up to 10 minutes total)
          for i in {1..20}; do
            kubectl logs "$POD_NAME" -n radius-system | tee registermanifest_logs.txt > /dev/null

            # Exit on error
            if grep -qi "Service initializer terminated with error" registermanifest_logs.txt; then
              echo "Error found in ucp logs."
              grep -i "Service initializer terminated with error" registermanifest_logs.txt
              exit 1
            fi

            # Check for success
            if grep -q "Successfully registered manifests" registermanifest_logs.txt; then
              echo "Successfully registered manifests - message found."
              break
            fi

            echo "Logs not ready, waiting 30 seconds..."
            sleep 30
          done

          # Final check to ensure success message was found
          if ! grep -q "Successfully registered manifests" registermanifest_logs.txt; then
            echo "Manifests not registered after 10 minutes."
            exit 1
          fi

      - name: Create resource types from resource folders
        run: |
          # Define common configuration
          setup_config() {
            resource_folders=("Compute" "Security")
            declare -g -A folder_to_namespace=(
              ["Compute"]="Radius.Compute"
              ["Security"]="Radius.Security"
            )
          }

          setup_config
          echo "Finding YAML files in resource type folders (safe handling of filenames)..."

          # Collect YAML files into a bash array safely (handles spaces/newlines)
          all_yaml_files=()
          for folder in "${resource_folders[@]}"; do
            if [[ -d "./$folder" ]]; then
              echo "Searching in folder: $folder"
              while IFS= read -r -d '' file; do
                all_yaml_files+=("$file")
              done < <(find "./$folder" -name "*.yaml" -type f -print0)
            else
              echo "Folder $folder does not exist, skipping..."
            fi
          done

          if [[ ${#all_yaml_files[@]} -eq 0 ]]; then
            echo "No YAML files found in any resource type folders"
            exit 0
          fi

          echo "Creating resource types..."
          for yaml_file in "${all_yaml_files[@]}"; do
            echo "Processing: $yaml_file"

            # Extract resource type name from the file path
            resource_name=$(basename "$yaml_file" .yaml)

            echo "Creating resource type '$resource_name' from $yaml_file..."
            if rad resource-type create "$resource_name" -f "$yaml_file"; then
              echo "‚úÖ Successfully created resource type: $resource_name"
            else
              echo "‚ùå Failed to create resource type: $resource_name"
              exit 1
            fi
          done

          echo "‚úÖ All resource types created successfully"

      - name: Verify expected resource types are present
        run: |
          # Define common configuration
          setup_config() {
            resource_folders=("Compute" "Security")
            declare -g -A folder_to_namespace=(
              ["Compute"]="Radius.Compute"
              ["Security"]="Radius.Security"
            )
          }
          
          setup_config
          echo "Listing all resource types..."
          rad resource-type list
          
          echo "Verifying expected resource types..."
          
          # Build expected resource types list dynamically
          expected_resource_types=()
          for folder in "${resource_folders[@]}"; do
            if [[ -d "./$folder" ]]; then
              folder_yaml_files=$(find "./$folder" -name "*.yaml" -type f)
              radius_namespace="${folder_to_namespace[$folder]}"
              for yaml_file in $folder_yaml_files; do
                resource_name=$(basename "$yaml_file" .yaml)
                expected_resource_types+=("$radius_namespace/$resource_name")
              done
            fi
          done
          
          if [[ ${#expected_resource_types[@]} -eq 0 ]]; then
            echo "No expected resource types found"
            exit 0
          fi
          
          echo "Expected resource types:"
          printf '%s\n' "${expected_resource_types[@]}"
          
          # Get the list of resource types
          resource_type_list=$(rad resource-type list)
          
          verification_failed=false
          
          for expected_type in "${expected_resource_types[@]}"; do
            echo "Checking for resource type: $expected_type"
            
            if echo "$resource_type_list" | grep -q "$expected_type"; then
              echo "‚úÖ Found resource type: $expected_type"
            else
              echo "‚ùå Missing resource type: $expected_type"
              verification_failed=true
            fi
          done
          
          if [[ "$verification_failed" == "true" ]]; then
            echo "‚ùå Resource type verification failed"
            echo "Expected resource types not found in the list"
            exit 1
          else
            echo "‚úÖ All expected resource types are present"
          fi

      - name: Publish Bicep extensions
        run: |
          # Define common configuration
          setup_config() {
            resource_folders=("Compute" "Security")
            declare -g -A folder_to_namespace=(
              ["Compute"]="Radius.Compute"
              ["Security"]="Radius.Security"
            )
          }

          setup_config
          echo "Publishing Bicep extensions for all YAML files (safe handling of filenames)..."

          all_yaml_files=()
          for folder in "${resource_folders[@]}"; do
            if [[ -d "./$folder" ]]; then
              while IFS= read -r -d '' file; do
                all_yaml_files+=("$file")
              done < <(find "./$folder" -name "*.yaml" -type f -print0)
            fi
          done

          if [[ ${#all_yaml_files[@]} -eq 0 ]]; then
            echo "No YAML files found in resource type folders"
            exit 0
          fi

          for yaml_file in "${all_yaml_files[@]}"; do
            echo "Publishing extension for $yaml_file..."

            resource_name=$(basename "$yaml_file" .yaml)
            extension_name="${resource_name}-extension"

            echo "Publishing extension '$extension_name.tgz' from $yaml_file..."
            if rad bicep publish-extension -f "$yaml_file" --target "$extension_name.tgz"; then
              echo "‚úÖ Successfully published extension: $extension_name.tgz"
            else
              echo "‚ùå Failed to publish extension: $extension_name.tgz"
              exit 1
            fi
          done

          echo "‚úÖ All Bicep extensions published successfully"

      - name: Update bicepconfig.json with published extensions
        run: |
          echo "Updating bicepconfig.json with published extensions..."
          
          # Find all published .tgz files and add them to bicepconfig.json (safe handling)
          tgz_files=()
          while IFS= read -r -d '' f; do
            tgz_files+=("$f")
          done < <(find . -name "*-extension.tgz" -type f -print0)

          if [[ ${#tgz_files[@]} -gt 0 ]]; then
            echo "Found extension files to add to bicepconfig.json:"
            printf '%s\n' "${tgz_files[@]}"

            for tgz_file in "${tgz_files[@]}"; do
              # Extract resource name from filename (e.g., "./containers-extension.tgz" -> "containers")
              filename=$(basename "$tgz_file")
              resource_name=${filename%-extension.tgz}

              echo "Adding extension '$resource_name' with file '$tgz_file' to bicepconfig.json..."

              # Update bicepconfig.json using jq
              jq --arg name "$resource_name" --arg path "$tgz_file" \
                '.extensions[$name] = $path' bicepconfig.json > bicepconfig.tmp && \
                mv bicepconfig.tmp bicepconfig.json
            done

            echo "‚úÖ Successfully updated bicepconfig.json with extensions"
          else
            echo "No extension .tgz files found to add to bicepconfig.json"
          fi

          echo "Final bicepconfig.json content:"
          cat bicepconfig.json

      - name: Register Kubernetes recipes
        run: |
          # Define common configuration
          setup_config() {
            resource_folders=("Compute" "Security")
            declare -g -A folder_to_namespace=(
              ["Compute"]="Radius.Compute"
              ["Security"]="Radius.Security"
            )
          }
          
          # Function to find recipe files by pattern across resource folders
          find_recipe_files() {
            local path_pattern="$1"
            local found_files=""
            for folder in "${resource_folders[@]}"; do
              if [[ -d "./$folder" ]]; then
                echo "Searching for recipes in $folder folder..."
                local folder_files=$(find "./$folder" -path "$path_pattern" -type f)
                if [[ -n "$folder_files" ]]; then
                  found_files="$found_files $folder_files"
                  echo "Found recipe files in $folder:"
                  echo "$folder_files"
                else
                  echo "No recipe files found in $folder folder"
                fi
              fi
            done
            echo "$found_files"
          }
          
          # Function to extract path components
          extract_path_info() {
            local file_path="$1"
            local root_folder=$(echo "$file_path" | sed 's|^./||' | cut -d'/' -f1)
            local resource_type=$(echo "$file_path" | sed 's|^./||' | cut -d'/' -f2)
            local platform_service=$(echo "$file_path" | sed 's|^./||' | cut -d'/' -f4)  # e.g., kubernetes
            local file_name=$(basename "$file_path")
            echo "$root_folder $resource_type $platform_service $file_name"
          }
          
          setup_config
          echo "Waiting for registry to be ready..."
          
          # Wait for the registry to respond
          for i in {1..15}; do
            if curl -fsS http://localhost:51351/v2/_catalog >/dev/null 2>&1; then
              echo "‚úÖ Registry is ready"
              break
            fi
            echo "Waiting for registry to be ready... ($i/15)"
            sleep 2
          done
          
          # Final check
          if ! curl -fsS http://localhost:51351/v2/_catalog >/dev/null 2>&1; then
            echo "‚ùå Registry is not ready after 30 seconds"
            exit 1
          fi
          
          echo "Finding and testing Kubernetes recipes (Bicep and Terraform)..."
          
          # Find Bicep recipe files
          bicep_recipes=()
          while IFS= read -r -d '' f; do
            bicep_recipes+=("$f")
          done < <(find . -path "*/recipes/kubernetes/*.bicep" -type f -print0)

          # Find Terraform recipe files (main.tf)
          terraform_recipes=()
          while IFS= read -r -d '' f; do
            terraform_recipes+=("$f")
          done < <(find . -path "*/recipes/kubernetes/main.tf" -type f -print0)

          if [[ ${#bicep_recipes[@]} -eq 0 && ${#terraform_recipes[@]} -eq 0 ]]; then
            echo "No Kubernetes recipe files found"
            exit 0
          fi

          echo "Found ${#bicep_recipes[@]} Bicep recipes and ${#terraform_recipes[@]} Terraform recipes"

          # Function to test a recipe type
          test_recipe_type() {
            local template_kind="$1"
            shift
            local recipes=("$@")
            
            if [[ ${#recipes[@]} -eq 0 ]]; then
              echo "No $template_kind recipes to test"
              return 0
            fi
            
            echo ""
            echo "üîÑ Testing $template_kind recipes..."
            
            # Group recipes by platform service
            declare -A platform_recipes
            for recipe_file in "${recipes[@]}"; do
              relpath="${recipe_file#./}"
              IFS='/' read -r root_folder resource_type _recipes_dir platform_service file_name <<< "$relpath"
              
              if [[ -z "$root_folder" || -z "$resource_type" || -z "$platform_service" ]]; then
                echo "‚ùå Unexpected recipe path structure: $recipe_file"
                exit 1
              fi
              
              platform_key="$root_folder/$resource_type/$platform_service"
              if [[ -z "${platform_recipes[$platform_key]}" ]]; then
                platform_recipes[$platform_key]="$recipe_file"
              else
                platform_recipes[$platform_key]="${platform_recipes[$platform_key]} $recipe_file"
              fi
            done

            # Process each platform service
            for platform_key in "${!platform_recipes[@]}"; do
              IFS='/' read -r root_folder resource_type platform_service <<< "$platform_key"
              echo ""
              echo "üîÑ Processing $template_kind recipe for: $platform_service ($root_folder/$resource_type)"
              
              # Get the Radius namespace
              radius_namespace="${folder_to_namespace[$root_folder]}"
              if [[ -z "$radius_namespace" ]]; then
                echo "‚ùå Unknown root folder: $root_folder"
                exit 1
              fi

              # Unregister any existing default recipe for this resource type
              echo "Unregistering any existing default recipe for $radius_namespace/$resource_type"
              rad recipe unregister default --environment default --resource-type "$radius_namespace/$resource_type" || echo "No existing default recipe to unregister"

              # Process recipes for this platform service
              for recipe_file in ${platform_recipes[$platform_key]}; do
                if [[ "$template_kind" == "bicep" ]]; then
                  recipe_name=$(basename "$recipe_file" .bicep)
                  registry_path="localhost:51351/recipes/$resource_type/$platform_service/$recipe_name:latest"
                  
                  echo "Publishing Bicep recipe '$recipe_name' to registry: $registry_path"
                  if rad bicep publish --file "$recipe_file" --target "br:$registry_path" --plain-http; then
                    echo "‚úÖ Successfully published Bicep recipe to registry"
                  else
                    echo "‚ùå Failed to publish Bicep recipe to registry"
                    exit 1
                  fi
                  
                  internal_registry_path="reciperegistry:5000/recipes/$resource_type/$platform_service/$recipe_name:latest"
                  echo "Registering Bicep recipe 'default' for resource type '$radius_namespace/$resource_type'"
                  if rad recipe register default --environment default --resource-type "$radius_namespace/$resource_type" --template-kind bicep --template-path "$internal_registry_path" --plain-http; then
                    echo "‚úÖ Successfully registered Bicep recipe as default"
                  else
                    echo "‚ùå Failed to register Bicep recipe as default"
                    exit 1
                  fi
                  
                elif [[ "$template_kind" == "terraform" ]]; then
                  # For Terraform, use the directory path
                  recipe_dir=$(dirname "$recipe_file")
                  echo "Registering Terraform recipe 'default' for resource type '$radius_namespace/$resource_type'"
                  if rad recipe register default --environment default --resource-type "$radius_namespace/$resource_type" --template-kind terraform --template-path "$recipe_dir"; then
                    echo "‚úÖ Successfully registered Terraform recipe as default"
                  else
                    echo "‚ùå Failed to register Terraform recipe as default"
                    exit 1
                  fi
                fi
              done
              
              # Deploy test application for this resource type
              test_app_path="$root_folder/$resource_type/app.bicep"
              
              if [[ -f "$test_app_path" ]]; then
                echo ""
                echo "üöÄ Deploying test application for $platform_service ($template_kind recipe)..."
                
                deployment_name="test-${root_folder,,}-${platform_service}-${template_kind}-$(date +%s)"
                
                echo "Deploying $test_app_path as application: $deployment_name"
                if rad deploy "$test_app_path" --application "$deployment_name"; then
                  echo "‚úÖ Successfully deployed test application using $template_kind recipe"
                  
                  # Clean up immediately
                  echo "Cleaning up deployment: $deployment_name"
                  rad app delete "$deployment_name" --yes || echo "‚ö†Ô∏è Failed to clean up deployment: $deployment_name"
                  echo "‚úÖ Cleaned up test deployment"
                else
                  echo "‚ùå Failed to deploy test application using $template_kind recipe"
                  exit 1
                fi
              else
                echo "‚ÑπÔ∏è No test application found at $test_app_path, skipping deployment test..."
              fi
              
              echo "‚úÖ Completed testing $template_kind recipe for $platform_service"
            done
          }

          # Test Bicep recipes first
          test_recipe_type "bicep" "${bicep_recipes[@]}"
          
          # Then test Terraform recipes
          test_recipe_type "terraform" "${terraform_recipes[@]}"

          echo ""
          echo "‚úÖ All Kubernetes recipes (Bicep and Terraform) tested successfully"

          echo "Listing all registered recipes..."
          rad recipe list --environment default
